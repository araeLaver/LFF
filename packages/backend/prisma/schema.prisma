// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

datasource db {
  provider = "postgresql"
  url      = "postgresql://user:password@127.0.0.1:5434/lff_db"
  
}

generator client {
  provider = "prisma-client-js"
}

model User {
  id                String             @id @default(cuid())
  email             String             @unique
  password          String?            // Optional for OAuth users
  provider          String?            // 'local', 'google', 'kakao'
  providerId        String?            // OAuth provider user ID
  role              Role               @default(USER)
  profile           Profile?
  wallet            Wallet?
  submissions       QuestSubmission[]
  createdAt         DateTime           @default(now())
  updatedAt         DateTime           @updatedAt
  creator           Creator?
  qrRedemptions     QRCodeRedemption[]
  notifications     Notification[]
  pushSubscriptions PushSubscription[]

  @@unique([provider, providerId])
}

model Profile {
  id        String   @id @default(cuid())
  nickname  String   @unique
  bio       String?
  avatarUrl String?
  user      User     @relation(fields: [userId], references: [id])
  userId    String   @unique
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Wallet {
  id         String      @id @default(cuid())
  address    String      @unique
  privateKey String?     // Only for platform-created wallets (should be encrypted)
  isExternal Boolean     @default(false) // true for user-connected wallets (MetaMask, etc.)
  chainId    Int?        // Chain ID for external wallets
  user       User        @relation(fields: [userId], references: [id])
  userId     String      @unique
  nfts       NFT[]
  createdAt  DateTime    @default(now())
  updatedAt  DateTime    @updatedAt
}

model Creator {
  id           String         @id @default(cuid())
  user         User           @relation(fields: [userId], references: [id])
  userId       String         @unique
  quests       Quest[]
  gatedContent GatedContent[]
  events       Event[]
  mintedNfts   NFT[]          // NFTs minted by this creator
  createdAt    DateTime       @default(now())
  updatedAt    DateTime       @updatedAt
}

model Event {
  id          String    @id @default(cuid())
  title       String
  description String?
  imageUrl    String?
  eventDate   DateTime
  creator     Creator   @relation(fields: [creatorId], references: [id])
  creatorId   String
  qrcodes     QRCode[]
  rewardNft   NFT?      @relation(fields: [rewardNftId], references: [id])
  rewardNftId String?   @unique
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
}

model QRCode {
  id          String             @id @default(cuid())
  code        String             @unique
  event       Event              @relation(fields: [eventId], references: [id])
  eventId     String
  redemptions QRCodeRedemption[]
  isActive    Boolean            @default(true)
  createdAt   DateTime           @default(now())
  updatedAt   DateTime           @updatedAt
}

model QRCodeRedemption {
  id        String   @id @default(cuid())
  qrcode    QRCode   @relation(fields: [qrCodeId], references: [id])
  qrCodeId  String
  user      User     @relation(fields: [userId], references: [id])
  userId    String
  createdAt DateTime @default(now())

  @@unique([qrCodeId, userId], name: "userRedeemedOnce")
}

model Quest {
  id           String            @id @default(cuid())
  title        String
  description  String
  imageUrl     String?
  rewardPoints Int
  creator      Creator           @relation(fields: [creatorId], references: [id])
  creatorId    String
  submissions  QuestSubmission[]
  createdAt    DateTime          @default(now())
  updatedAt    DateTime          @updatedAt
}

model QuestSubmission {
  id       String           @id @default(cuid())
  user     User             @relation(fields: [userId], references: [id])
  userId   String
  quest    Quest            @relation(fields: [questId], references: [id])
  questId  String
  status   SubmissionStatus @default(PENDING)
  proofUrl String?
  createdAt DateTime         @default(now())
  updatedAt DateTime         @updatedAt
}

model GatedContent {
  id                  String        @id @default(cuid())
  title               String
  description         String?
  contentType         ContentType   @default(OTHER)
  contentUrl          String        // URL to the actual content
  previewUrl          String?       // Preview image/thumbnail
  requiredNftContract String?       // Contract address for access control
  requiredTokenId     String?       // Specific token ID (optional)
  requiredNft         NFT?          @relation(fields: [requiredNftId], references: [id])
  requiredNftId       String?
  status              ContentStatus @default(PUBLISHED)
  creator             Creator       @relation(fields: [creatorId], references: [id])
  creatorId           String
  createdAt           DateTime      @default(now())
  updatedAt           DateTime      @updatedAt
}

enum ContentType {
  VIDEO
  IMAGE
  AUDIO
  DOCUMENT
  OTHER
}

enum ContentStatus {
  DRAFT
  PUBLISHED
}

model NFT {
  id              String         @id @default(cuid())
  tokenId         String         @unique
  contractAddress String
  metadataUrl     String
  tokenType       TokenType?     // SBT type (EVENT_ATTENDANCE, QUEST_COMPLETION)
  referenceId     String?        // Quest ID or Event ID
  name            String?
  description     String?
  imageUrl        String?
  transactionHash String?        // Blockchain transaction hash
  mintedBy        Creator?       @relation(fields: [mintedById], references: [id])
  mintedById      String?        // Creator who minted this NFT
  owner           Wallet         @relation(fields: [ownerId], references: [id])
  ownerId         String
  gatedContent    GatedContent[]
  createdAt       DateTime       @default(now())
  updatedAt       DateTime       @updatedAt
  eventRewardFor  Event?
}

enum TokenType {
  EVENT_ATTENDANCE
  QUEST_COMPLETION
}

enum Role {
  USER
  CREATOR
  ADMIN
}

enum SubmissionStatus {
  PENDING
  APPROVED
  REJECTED
}

model Notification {
  id        String           @id @default(cuid())
  type      NotificationType
  title     String
  message   String
  data      Json?            // Additional data (questId, eventId, etc.)
  isRead    Boolean          @default(false)
  user      User             @relation(fields: [userId], references: [id])
  userId    String
  createdAt DateTime         @default(now())
}

model PushSubscription {
  id        String   @id @default(cuid())
  endpoint  String   @unique
  p256dh    String   // Public key
  auth      String   // Auth secret
  user      User     @relation(fields: [userId], references: [id])
  userId    String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

enum NotificationType {
  QUEST_APPROVED
  QUEST_REJECTED
  EVENT_REMINDER
  NEW_CONTENT
  NFT_MINTED
  SYSTEM
}